<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Grid Decoder</title>
<style>
  video, canvas {
    width: 640px; height: 480px;
    border: 2px solid #444; border-radius: 8px;
    display: block; margin-bottom: 10px;
  }
  #transcript {
    font-size: 1.2em;
    margin-top: 10px;
    background: #eee;
    padding: 10px;
    width: 640px;
    font-family: monospace;
  }

</style>
</head>
<body>
<h2>ðŸ“¡ Grid Decoder</h2>
<button id="screenBtn">Share Screen</button>
<button id="cameraBtn">Use Camera</button>
<button id="finalizeBtn">Finalize ROI</button>
<video id="video" autoplay playsinline></video>
<canvas id="canvas" width="640" height="480"></canvas>
<div id="transcript">Transcript: <span id="output"></span></div>

<script>
const GRID_ROWS = 5, GRID_COLS = 6;
const video = document.getElementById('video');
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const output = document.getElementById('output');

let roi = null;           // region of interest (grid area)
let cellWidth, cellHeight;
let letterMap = {};
let lastDetected = null;
let transcript = "";

// Map letters to grid coordinates
let idx = 0;
for(let r=0; r<GRID_ROWS; r++){
  for(let c=0; c<GRID_COLS; c++){
    if(idx < 26){
      letterMap[`${r},${c}`] = String.fromCharCode(97 + idx);
      idx++;
    }
  }
}
letterMap["4,2"] = " "; // space

// --- screen capture ---
document.getElementById('screenBtn').onclick = async () => {
  const stream = await navigator.mediaDevices.getDisplayMedia({ video: true });
  video.srcObject = stream;
  video.onloadedmetadata = () => autoCalibrate();
};
document.getElementById('cameraBtn').onclick = async () => {
  try {
    const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } });
    video.srcObject = stream;

    roi = { x: 50, y: 50, w: 300, h: 200 }; // initial guess
    cellWidth = roi.w / GRID_COLS;
    cellHeight = roi.h / GRID_ROWS;

    const handles = [
      { x: roi.x, y: roi.y, cursor: "nwse-resize", corner: "tl" },
      { x: roi.x + roi.w, y: roi.y, cursor: "nesw-resize", corner: "tr" },
      { x: roi.x, y: roi.y + roi.h, cursor: "nesw-resize", corner: "bl" },
      { x: roi.x + roi.w, y: roi.y + roi.h, cursor: "nwse-resize", corner: "br" }
    ];
    let dragging = null;
    let showHandles = true; // keep handles visible until finalize

    function drawLoop() {
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.drawImage(video,0,0,canvas.width,canvas.height);

      if(showHandles){
        ctx.strokeStyle = "red";
        ctx.lineWidth = 2;
        ctx.strokeRect(roi.x, roi.y, roi.w, roi.h);

        for(const h of handles){
          ctx.fillStyle = "white";
          ctx.strokeStyle = "black";
          ctx.fillRect(h.x-10,h.y-10,20,20);
          ctx.strokeRect(h.x-10,h.y-10,20,20);
        }
      }

      requestAnimationFrame(drawLoop);
    }
    drawLoop();

    function getTouchPos(e){
      const rect = canvas.getBoundingClientRect();
      const touch = e.touches[0] || e.changedTouches[0];
      return { x: touch.clientX - rect.left, y: touch.clientY - rect.top };
    }

    canvas.addEventListener("touchstart", e => {
      const pos = getTouchPos(e);
      for(const h of handles){
        if(pos.x >= h.x-20 && pos.x <= h.x+20 && pos.y >= h.y-20 && pos.y <= h.y+20){
          dragging = h;
          e.preventDefault();
          break;
        }
      }
    });

    canvas.addEventListener("touchmove", e => {
      if(dragging){
        const pos = getTouchPos(e);
        switch(dragging.corner){
          case "tl":
            roi.w += roi.x - pos.x; roi.h += roi.y - pos.y;
            roi.x = pos.x; roi.y = pos.y;
            break;
          case "tr":
            roi.w = pos.x - roi.x; roi.h += roi.y - pos.y;
            roi.y = pos.y;
            break;
          case "bl":
            roi.w += roi.x - pos.x; roi.h = pos.y - roi.y;
            roi.x = pos.x;
            break;
          case "br":
            roi.w = pos.x - roi.x; roi.h = pos.y - roi.y;
            break;
        }
        // Update handle positions
        handles[0].x = roi.x; handles[0].y = roi.y;
        handles[1].x = roi.x+roi.w; handles[1].y = roi.y;
        handles[2].x = roi.x; handles[2].y = roi.y+roi.h;
        handles[3].x = roi.x+roi.w; handles[3].y = roi.y+roi.h;
        e.preventDefault();
      }
    });

    canvas.addEventListener("touchend", e => {
      dragging = null;
    });

    // Finalize button
    document.getElementById('finalizeBtn').onclick = () => {
      showHandles = false; // hide rectangle and handles
      cellWidth = roi.w / GRID_COLS;
      cellHeight = roi.h / GRID_ROWS;
      analyzeFrames();
    };

  } catch(e) {
    alert("Camera access failed.");
    console.error(e);
  }
};

// --- auto-calibration to detect grid bounds ---
function autoCalibrate(){
  const attempts = 10;
  let count = 0;
  let sumX1=0,sumY1=0,sumX2=0,sumY2=0;

  const capture = () => {
    ctx.drawImage(video,0,0,canvas.width,canvas.height);
    const img = ctx.getImageData(0,0,canvas.width,canvas.height);
    const data = img.data;

    // simple brightness map: detect the brightest rectangle
    let minX=canvas.width,minY=canvas.height,maxX=0,maxY=0;
    for(let y=0;y<canvas.height;y+=2){
      for(let x=0;x<canvas.width;x+=2){
        const i = (y*canvas.width+x)*4;
        const brightness = (data[i]+data[i+1]+data[i+2])/3;
        if(brightness>200){ // white cell or background
          minX=Math.min(minX,x);
          minY=Math.min(minY,y);
          maxX=Math.max(maxX,x);
          maxY=Math.max(maxY,y);
        }
      }
    }

    sumX1 += minX; sumY1 += minY; sumX2 += maxX; sumY2 += maxY;
    count++;
    if(count<attempts){
    console.log(2)
      requestAnimationFrame(capture);
    } else {
      roi = {
        x: Math.floor(sumX1/attempts),
        y: Math.floor(sumY1/attempts),
        w: Math.floor(sumX2/attempts)-Math.floor(sumX1/attempts),
        h: Math.floor(sumY2/attempts)-Math.floor(sumY1/attempts)
      };
      console.log(1)
    const TITLE_BAR_HEIGHT = 30;
      roi.h -= TITLE_BAR_HEIGHT;
      roi.y+=TITLE_BAR_HEIGHT;
      cellWidth = roi.w/GRID_COLS;
      cellHeight = roi.h/GRID_ROWS;
      console.log("âœ… Auto-calibrated ROI:", roi);
      analyzeFrames();
    }
  };
  capture();
}

// --- analyze frames ---
function analyzeFrames(){
  function loop(){
    if(!roi) return;
    ctx.drawImage(video,0,0,canvas.width,canvas.height);
    const img = ctx.getImageData(roi.x,roi.y,roi.w,roi.h);
    const data = img.data;

    // find darkest cell (blinking black cell)
    let darkest={r:0,c:0,brightness:255};
    for(let r=0;r<GRID_ROWS;r++){
      for(let c=0;c<GRID_COLS;c++){
        let sum=0,count=0;
        for(let yy=Math.floor(r*cellHeight); yy<Math.floor((r+1)*cellHeight); yy+=2){
          for(let xx=Math.floor(c*cellWidth); xx<Math.floor((c+1)*cellWidth); xx+=2){
            const i = (yy*roi.w+xx)*4;
            const bright = (data[i]+data[i+1]+data[i+2])/3;
            sum+=bright; count++;
          }
        }
        const avg = sum/count;
        if(avg<darkest.brightness){
          darkest={r,c,brightness:avg};
        }
      }
    }

    const key = `${darkest.r},${darkest.c}`;
    const letter = letterMap[key];
    if(letter && letter!==lastDetected && darkest.brightness<200){ // black cell detected
      transcript += letter;
      output.textContent = transcript;
      lastDetected = letter;
    }
    if(darkest.brightness>200) lastDetected = null; // reset when cell turns back white

    requestAnimationFrame(loop);
  }
  loop();
}
</script>

</body>
</html>
