<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Grid Decoder</title>
<style>
  video, canvas {
    width: 640px; height: 480px;
    border: 2px solid #444; border-radius: 8px;
    display: block; margin-bottom: 10px;
  }
  #transcript {
    font-size: 1.2em;
    margin-top: 10px;
    background: #eee;
    padding: 10px;
    width: 640px;
    font-family: monospace;
  }

</style>
</head>
<body>
<h2>ðŸ“¡ Grid Decoder</h2>
<button id="screenBtn">Share Screen</button>
<button id="cameraBtn">Use Camera</button>
<video id="video" autoplay playsinline></video>
<canvas id="canvas" width="640" height="480"></canvas>
<div id="transcript">Transcript: <span id="output"></span></div>

<script>
const GRID_ROWS = 5, GRID_COLS = 6;
const video = document.getElementById('video');
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const output = document.getElementById('output');

let roi = null;           // region of interest (grid area)
let cellWidth, cellHeight;
let letterMap = {};
let lastDetected = null;
let transcript = "";

// Map letters to grid coordinates
let idx = 0;
for(let r=0; r<GRID_ROWS; r++){
  for(let c=0; c<GRID_COLS; c++){
    if(idx < 26){
      letterMap[`${r},${c}`] = String.fromCharCode(97 + idx);
      idx++;
    }
  }
}
letterMap["4,2"] = " "; // space

// --- screen capture ---
document.getElementById('screenBtn').onclick = async () => {
  const stream = await navigator.mediaDevices.getDisplayMedia({ video: true });
  video.srcObject = stream;
  video.onloadedmetadata = () => autoCalibrate();
};
// --- phone camera with auto grid detection ---
document.getElementById('cameraBtn').onclick = async () => {
  try {
    const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } });
    video.srcObject = stream;
    video.onloadedmetadata = () => {
      // Wait for OpenCV to load
      if (typeof cv === 'undefined') {
        console.error("OpenCV.js not loaded yet.");
        return;
      }
      startCameraGridDetection();
    };
  } catch(e) {
    alert("Camera access failed.");
    console.error(e);
  }
};

function startCameraGridDetection() {
  const src = new cv.Mat(video.videoHeight, video.videoWidth, cv.CV_8UC4);
  const gray = new cv.Mat();
  const edges = new cv.Mat();
  const contours = new cv.MatVector();
  const hierarchy = new cv.Mat();

  function processFrame() {
    if(video.paused || video.ended) {
      requestAnimationFrame(processFrame);
      return;
    }

    // Draw current video frame to canvas
    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

    // Read pixels from canvas to OpenCV mat
    let imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    src.data.set(imageData.data);

    // Convert to grayscale
    cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0);

    // Detect edges
    cv.Canny(gray, edges, 50, 150);

    // Find contours
    cv.findContours(edges, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

    let bestRect = null;
    for(let i=0; i<contours.size(); i++) {
      let cnt = contours.get(i);
      let rect = cv.boundingRect(cnt);
      let aspect = rect.width / rect.height;
      if(aspect > 1.1 && aspect < 1.4) { // approx 6/5 ratio
        if(!bestRect || rect.width*rect.height > bestRect.width*bestRect.height) {
          bestRect = rect;
        }
      }
    }

    if(bestRect) {
      // Draw detected rectangle on canvas
      ctx.strokeStyle = "red";
      ctx.lineWidth = 3;
      ctx.strokeRect(bestRect.x, bestRect.y, bestRect.width, bestRect.height);

      // Update ROI for your existing analyzeFrames logic
      roi = {
        x: bestRect.x,
        y: bestRect.y,
        w: bestRect.width,
        h: bestRect.height
      };
      cellWidth = roi.w / GRID_COLS;
      cellHeight = roi.h / GRID_ROWS;
    }

    requestAnimationFrame(processFrame);
  }

  processFrame();
}

// --- auto-calibration to detect grid bounds ---
function autoCalibrate(){
  const attempts = 10;
  let count = 0;
  let sumX1=0,sumY1=0,sumX2=0,sumY2=0;

  const capture = () => {
    ctx.drawImage(video,0,0,canvas.width,canvas.height);
    const img = ctx.getImageData(0,0,canvas.width,canvas.height);
    const data = img.data;

    // simple brightness map: detect the brightest rectangle
    let minX=canvas.width,minY=canvas.height,maxX=0,maxY=0;
    for(let y=0;y<canvas.height;y+=2){
      for(let x=0;x<canvas.width;x+=2){
        const i = (y*canvas.width+x)*4;
        const brightness = (data[i]+data[i+1]+data[i+2])/3;
        if(brightness>200){ // white cell or background
          minX=Math.min(minX,x);
          minY=Math.min(minY,y);
          maxX=Math.max(maxX,x);
          maxY=Math.max(maxY,y);
        }
      }
    }

    sumX1 += minX; sumY1 += minY; sumX2 += maxX; sumY2 += maxY;
    count++;
    if(count<attempts){
    console.log(2)
      requestAnimationFrame(capture);
    } else {
      roi = {
        x: Math.floor(sumX1/attempts),
        y: Math.floor(sumY1/attempts),
        w: Math.floor(sumX2/attempts)-Math.floor(sumX1/attempts),
        h: Math.floor(sumY2/attempts)-Math.floor(sumY1/attempts)
      };
      console.log(1)
    const TITLE_BAR_HEIGHT = 30;
      roi.h -= TITLE_BAR_HEIGHT;
      roi.y+=TITLE_BAR_HEIGHT;
      cellWidth = roi.w/GRID_COLS;
      cellHeight = roi.h/GRID_ROWS;
      console.log("âœ… Auto-calibrated ROI:", roi);
      analyzeFrames();
    }
  };
  capture();
}

// --- analyze frames ---
function analyzeFrames(){
  function loop(){
    if(!roi) return;
    ctx.drawImage(video,0,0,canvas.width,canvas.height);
    const img = ctx.getImageData(roi.x,roi.y,roi.w,roi.h);
    const data = img.data;

    // find darkest cell (blinking black cell)
    let darkest={r:0,c:0,brightness:255};
    for(let r=0;r<GRID_ROWS;r++){
      for(let c=0;c<GRID_COLS;c++){
        let sum=0,count=0;
        for(let yy=Math.floor(r*cellHeight); yy<Math.floor((r+1)*cellHeight); yy+=2){
          for(let xx=Math.floor(c*cellWidth); xx<Math.floor((c+1)*cellWidth); xx+=2){
            const i = (yy*roi.w+xx)*4;
            const bright = (data[i]+data[i+1]+data[i+2])/3;
            sum+=bright; count++;
          }
        }
        const avg = sum/count;
        if(avg<darkest.brightness){
          darkest={r,c,brightness:avg};
        }
      }
    }

    const key = `${darkest.r},${darkest.c}`;
    const letter = letterMap[key];
    if(letter && letter!==lastDetected && darkest.brightness<200){ // black cell detected
      transcript += letter;
      output.textContent = transcript;
      lastDetected = letter;
    }
    if(darkest.brightness>200) lastDetected = null; // reset when cell turns back white

    requestAnimationFrame(loop);
  }
  loop();
}
</script>
<script async src="https://docs.opencv.org/4.x/opencv.js" type="text/javascript"></script>
</body>
</html>
